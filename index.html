<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 柳溪的个人博客</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"></head><body><div id="mask" style="display: none;"><img id="mask-image" src="#" style=" "></div><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/resume" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/17/linux-sed/" class="post-title-link">linux-sed高级用法</a></h2><div class="post-time">Apr 17, 2016</div><div class="post-content"><p>sed是一个流文本处理编辑器，一般我们使用的用法只是一行一行的处理文本，如果我们想对多行同时处理的话，就必须用到sed的高级命令了。举个例子，我们想要把```R与````中间的行前面都加上一个tab键，就可以用如下方法：</p></div><a href="/2016/04/17/linux-sed/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/27/linux-管线命令/" class="post-title-link">linux 管线命令</a></h2><div class="post-time">Mar 27, 2016</div><div class="post-content"><p>如果你想要得到的数据要经过很多道工序才能得出，那么就得用上管线命令了(pipe)，管线命令使用的是 | 这个符号。</p>
<blockquote>
<p>管线命令只能处理前面一个指令传来的正确信息，也就是standard output信息，不能处理standard error信息。<br>每个管线后面接的第一个数据必须是指令，并且是能接受标准输入的指令，只有这样才能称为管线命令。</p>
</blockquote>
<p>常用的管线命令有：</p>
<pre><code>撷取命令: cut, grep
排序命令: sort, wc, uniq
双向重导向: tee
字符转换命令: tr, col, join, paste, expand
分割命令: split
参数代换: xargs
</code></pre></div><a href="/2016/03/27/linux-管线命令/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/01/08/svg-viewbox（二）/" class="post-title-link">理解svg坐标系统及变化（二）</a></h2><div class="post-time">Jan 8, 2016</div><div class="post-content"><h4 id="svg坐标系统变化"><a href="#svg坐标系统变化" class="headerlink" title="svg坐标系统变化"></a>svg坐标系统变化</h4><p>svg能够通过坐标系统的变化来使得图形达到缩放、平移、变形和旋转的效果。<br>svg的transform属性和viewBox属性是两个能在元素上应用新建用户坐标系统的属性。<br>当svg元素应用transform属性时，这个元素复制一个当前用户坐标系统也就是viewBox，然后再对这个复制的坐标系统上进行各种变化操作，svg图形就是在这个变化后的坐标系统上作图的。</p></div><a href="/2016/01/08/svg-viewbox（二）/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/01/01/svg-viewbox（一）/" class="post-title-link">理解svg坐标系统及变化（一）</a></h2><div class="post-time">Jan 1, 2016</div><div class="post-content"><p>The viewport, viewBox, and preserveAspectRatio<br>SVG元素是不受CSS盒模型控制的，这使得定位及变化这些元素没那么直观。但是当你理解呢SVG坐标系统及变化的工作原理，操控SVG将变得非常容易。本篇文章将介绍控制SVG坐标系统的三个非常重要的属性：viewport, viewBox, and preserveAspectRatio</p></div><a href="/2016/01/01/svg-viewbox（一）/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/12/12/css元素及其盒模型(二)/" class="post-title-link">css元素及盒模型（二）</a></h2><div class="post-time">Dec 12, 2015</div><div class="post-content"><p>上节大部分讲的是块元素，这小节讨论下行内元素。行内元素见到最多的就是行内非置换元素em、a<br>,行内置换元素img</p>
<h4 id="行内元素的布局"><a href="#行内元素的布局" class="headerlink" title="行内元素的布局"></a>行内元素的布局</h4><h6 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h6><p>Anonymous text 匿名文本</p>
<pre><code>&lt;p&gt; I&apos;m &lt;em&gt;so&lt;/em&gt; happy!&lt;/p&gt; 
&apos;I’m&apos;和 &apos;happy!&apos;是匿名文本
</code></pre><p>Content area内容区:高度由font-size决定</p></div><a href="/2015/12/12/css元素及其盒模型(二)/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/12/11/css元素及其盒模型(一)/" class="post-title-link">css元素及盒模型（一）</a></h2><div class="post-time">Dec 11, 2015</div><div class="post-content"><p>CSS中，每个元素会产生一个或者多个矩形盒，称为元素盒。元素盒的中心区域是内容区域，由内向外依次被padding，border,margin区域包裹。这些包裹的区域都可以设置为0，其中只有margin能设负值。<br>内容区域的背景，默认是延伸至border边界下面。这可以在border样式设置为虚线时清楚的看到。border的颜色在没有设置的情况下，默认为元素内容的颜色。</p></div><a href="/2015/12/11/css元素及其盒模型(一)/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/12/04/逻辑运算符&amp;&amp;和||的另类应用/" class="post-title-link">js逻辑运算符&&和||的另类应用</a></h2><div class="post-time">Dec 4, 2015</div><div class="post-content"><p>逻辑运算符“&amp;&amp;”、“||”是对操作数进行布尔算术运算，我们经常碰到的是和关系运算符配合使用的情况。但是对真值和假值的布尔操作却了解不多。下面我们就从三个层次加深对逻辑运算符的理解。<br></div><a href="/2015/12/04/逻辑运算符&amp;&amp;和||的另类应用/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/11/27/利用relative与absolute做照片墙/" class="post-title-link">利用relative与absolute做照片墙</a></h2><div class="post-time">Nov 27, 2015</div><div class="post-content"><p>relative相对定位，元素不脱离文本流，移动元素后会形成空的占位符，不会对其他元素的排版造成影响。<br>absolute绝对定位，元素脱离文本流，相对于最近的已定位的祖先元素定位，未设置定位尺寸的情况下，浮动于原来所占文本流的位置上。</p></div><a href="/2015/11/27/利用relative与absolute做照片墙/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/11/18/利用border属性生成三角形/" class="post-title-link">利用border属性画三角形</a></h2><div class="post-time">Nov 18, 2015</div><div class="post-content"><p>对于border属性大家都不陌生，我们经常会这么设置一个元素的border属性：</p>
<pre><code>div.rec{
    border-left:20px solid #F00;
    border-right:20px solid #F00;
    border-top:20px solid #00F;
    border-bottom:20px solid #00F;
    width:100px;
    height:100px;
    }
</code></pre></div><a href="/2015/11/18/利用border属性生成三角形/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/11/17/elasctisearch/" class="post-title-link">elasticsearch之数据导入</a></h2><div class="post-time">Nov 17, 2015</div><div class="post-content"><h4 id="数据批量导入"><a href="#数据批量导入" class="headerlink" title="数据批量导入"></a>数据批量导入</h4><p>通过bulk API可以批量导入新建的文档。格式由两个JSON格式的文档组成，每个文档由空行隔开，各占一行。第一个文档由操作类型如(index，index会覆盖已存在的相同ID的文档，如果不想覆盖则用create操作方法）和元数据组成,如(index,type,ID)；第二个文档则是要index文档的内容。文档代码示例如下：</p>
<pre><code>{&quot;index&quot;:{&quot;_index&quot;:&quot;get-together&quot;, &quot;_type&quot;:&quot;group&quot;, &quot;_id&quot;:&quot;10&quot;}}
{&quot;name&quot;:&quot;Elasticsearch Bucharest&quot;}
{&quot;index&quot;:{&quot;_index&quot;:&quot;get-together&quot;, &quot;_type&quot;:&quot;group&quot;, &quot;_id&quot;:&quot;11&quot;}}
{&quot;name&quot;:&quot;Big Data Bucharest&quot;}
</code></pre></div><a href="/2015/11/17/elasctisearch/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/08/25/rvest-图书扒取/" class="post-title-link">R-rvest网页数据爬取</a></h2><div class="post-time">Aug 25, 2015</div><div class="post-content"><p>在网页数据爬取过程中，有时候用rvest::read_html()读取网页的内容和我们直接分析页码的源代码不一样，或者直接就是乱码。这两个常见问题可能是由user agent和编码设置错误有关。关于编码的重新设置可以采用以下这种方法：<br>用下载的函数（例如download.file）下载网页下来，然后读取出内容，用stringi扩展包中的<br>stri_enc_detect探测出字符串的编码，然后用string::stri_encode将原编码转换成为UTF8就可以了。<br></div><a href="/2015/08/25/rvest-图书扒取/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/08/16/data.table语法解析（二）/" class="post-title-link">R-data.table语法解析（二）</a></h2><div class="post-time">Aug 16, 2015</div><div class="post-content"><pre><code>library(data.table)
DT = data.table(a=LETTERS[c(1,1:3)],b=4:7,key=&quot;a&quot;)
DT
</code></pre></div><a href="/2015/08/16/data.table语法解析（二）/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/08/15/data.table语法解析（一）/" class="post-title-link">R-data.table语法解析（一）</a></h2><div class="post-time">Aug 15, 2015</div><div class="post-content"><p>R-data.table</p>
<p>上一节介绍了最基本的如何操作data.frame的行列来实现各种功能需求的数据计算。这一节将介绍另外一个功能更加强大的R包:data.table</p>
<pre><code>library(data.table)
DT = data.table(x=rep(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;),each=3), y=c(1,3,6), v=1:9);
</code></pre></div><a href="/2015/08/15/data.table语法解析（一）/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/08/13/R 数据处理/" class="post-title-link">R数据处理</a></h2><div class="post-time">Aug 13, 2015</div><div class="post-content"><h4 id="R-数据处理"><a href="#R-数据处理" class="headerlink" title="R 数据处理"></a>R 数据处理</h4><p>本节数据处理主要是针对data.frame数据结构，由最基本的方法到运用dplyr包，reshape包等对数据进行加工及运算。<br>下面通过具体实例学习R数据处理。</p>
<p>这是三家公司的营收与利润数额。如果大家想一步步跟随本文进行尝试，那么请将下列内容输入（或者直接复制加粘贴）到自己的R终端窗口当中：</p>
<pre><code>fy &lt;- c(2010,2011,2012,2010,2011,2012,2010,2011,2012);
company &lt;- c(&quot;Apple&quot;,&quot;Apple&quot;,&quot;Apple&quot;,&quot;Google&quot;,&quot;Google&quot;,&quot;Google&quot;,&quot;Microsoft&quot;,&quot;Microsoft&quot;,&quot;Microsoft&quot;); 
revenue &lt;- c(65225,108249,156508,29321,37905,50175,62484,69943,73723);  
profit &lt;- c(14013,25922,41733,8505,9737,10737,18760,23150,16978);
companiesData &lt;- data.frame(fy, company, revenue, profit);
companiesData$fy &lt;- as.factor(companiesData$fy);
companiesData;
str(companiesData)
</code></pre></div><a href="/2015/08/13/R 数据处理/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/08/12/R文本处理/" class="post-title-link">R文本处理</a></h2><div class="post-time">Aug 12, 2015</div><div class="post-content"><h4 id="1-字符串统计和字符翻译"><a href="#1-字符串统计和字符翻译" class="headerlink" title="1 字符串统计和字符翻译"></a>1 字符串统计和字符翻译</h4><p>1.1 nchar和length<br>nchar向量元素的字符个数，length向量长度（向量元素的个数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(&quot;Hellow&quot;, &quot;World&quot;, &quot;!&quot;);</span><br><span class="line">nchar(x) /6,5,1</span><br></pre></td></tr></table></figure></div><a href="/2015/08/12/R文本处理/" class="read-more">...more</a></article></li></ul></section><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://yoursite.com">John Doe</a>, unless otherwise noted.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/css/app.js"></script></body></html>